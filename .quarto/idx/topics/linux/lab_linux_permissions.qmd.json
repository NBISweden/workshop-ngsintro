{"title":"File permissions","markdown":{"yaml":{"title":"File permissions","subtitle":"Ownership and permissions for files and folders","author":"Martin Dahlö","format":"html"},"headingText":"Ownership & Permissions","containsRefs":false,"markdown":"\n\n```{r,eval=TRUE,include=FALSE}\nlibrary(yaml)\nlibrary(here)\nupid <- yaml::read_yaml(here(\"_quarto.yml\"))$uppmax_project\n```\n\n::: {.callout-note}\nIn code blocks, the dollar sign (`$`) is not to be printed. The dollar sign is usually an indicator that the text following it should be typed in a terminal window.\n:::\n\n\nAs Linux can be a multi-user environment it is important that files and directories can have different owners and permissions to keep people from editing or executing your files.\n\n### Owners\n\nThe permissions are defined separately for **users**, **groups** and **others**.\n\nThe **user** is the username of the person who owns the file. By default the user who creates a file will become its owner. The **group** is a group of users that co-own the file. They will all have the same permissions to the file. This is useful in any project where a group of people are working together. The **others** is quite simply everyone else's permissions.\n\n### Permissions\n\nThere are four permissions that a file or directory can have. Note the one character designations/flags, **`r`**,**`w`**,**`x`**  and  **`-`**.\n\nIn all cases, if the file or directory has the flag it means that it is enabled.\n\n**Read: `r`**\n\nFile: Whether the file can be opened and read.  \nDirectory: Whether the contents of the directory can be listed.\n\n**Write: `w`**\n\nFile: Whether the file can be modified. (*Note that for renaming or deleting a file you need additional directory permissions.*)  \nDirectory: Whether the files in the directory can be renamed or deleted.\n\n**Execute: `x`**\n\nFile: Whether the file can be executed as a program or shell script.  \nDirectory: Whether the directory can be entered using `cd`.\n\n**No permissions: `-`**\n\n## Interpreting permissions\n\nMake an empty directory we can work in and make a file.\n\n```{r,echo=FALSE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ cd /proj/',upid,'/nobackup/username\n$ mkdir advlinux\n$ cd advlinux\n$ touch  filename\n$ ls -lh\ntotal 0\n -rw-r--r-- 1 S_D staff 0B Sep 21 13:54 filename'))\n```\n\n(`-lh` means long and human readable, displaying more information about the files or directories in a human understandable format)\n\nThis shows us a cryptic line for each file/folder, where the columns are as following:\n\n```\n-rw-rw-r--   : permissions\n1            : number of linked hard-links\nS_D          : owner of the file\nstaff        : to which group this file belongs to\n0            : file size\nSep 21 13:54 : modification/creation date and time\nfilename     : file/directory name\n```\n\n\nThe first segment, `-rw-r--r--`, describes the ownerships and permissions of our newly created file. The very first character, in this case `-`, shows the file's type. It can be any of these:\n\n**`d`** = directory\n**`-`** = regular file\n**`l`** = symbolic link\n**`s`** = Unix domain socket\n**`p`** = named pipe\n**`c`** = character device file\n**`b`** = block device file\n\nAs expected the file we have just created is a regular file. Ignore the types other than directory, regular and symbolic link as they are outside the scope of this course.\n\nThe next nine characters, in our case `rw-r--r--`, can be divided into three groups consisting of three characters in order from left to right. In our case `rw-`, `r--` and `r--`. The first group designates the **users** permissions, the second the **groups** permissions and the third the **others** permissions. As you may have guessed the within group permissions are ordered, the first always designates read permissions, the second write and the third executability.\n\nThis translates our files permissions to say this `-rw-r--r--`:\n\n```\n- It is a regular file.\n- The user has read & write permission, but not execute.\n- The group has read permission but not write and execute.\n- Everyone else (other), have read permission but not write and execute.\n```\n\nAs another example, lets create a directory.\n\n```bash\n$ mkdir directoryname\n$ ls -lh\ntotal 0\ndrwxr-xr-x  2 S_D  staff    68B Sep 21 14:41 directoryname\n-rw-r--r--  1 S_D  staff     0B Sep 21 13:54 filename\n```\n\nAs you can see the first character correctly identifies it as **`d`**, a directory, and all user groups have **`x`**, execute permissions, to enter the directory by default.\n\n## Editing Ownership & Permissions\n\nThe command to set file permission is `chmod` which means **CH**ange **MOD**e. Only the owner can set file permissions.\n\n1. First you decide which group you want to set permissions for. User, **`u`**, group, **`g`**, other, **`o`**, or all three, **`a`**.\n2. Next you either add, **`+`**, remove, **`-`**, or wipe out previous and add new, **`=`**, permissions.\n3. Then you specify the kind of permission: **`r`**,**`w`**,**`x`**, or **`-`**.\n\nLets revisit our example file and directory to test this.\n\n```bash\n$ ls -lh\ntotal 0\ndrwxr-xr-x  2 S_D  staff    68B Sep 21 14:41 directoryname\n-rw-r--r--  1 S_D  staff     0B Sep 21 13:54 filename\n$ chmod a=x filename\n$ ls -lh\ntotal 0\ndrwxr-xr-x  2 S_D  staff    68B Sep 21 14:41 directoryname\n---x--x--x  1 S_D  staff     0B Sep 21 13:54 filename\n```\n\nAs you can see this affected all three, **`a`**, it wiped the previous permissions, **`=`**, and added an executable permission, **`x`**, to all three groups.\n\nTry some others both on the file and directory to get the hang of it.\n\n```bash\n$ chmod g+r filename\n$ chmod u-x filename\n$ chmod ug=rx filename\n$ chmod a=- filename\n$ chmod a+w directoryname\n```\n\n{{< fa clipboard-list >}} In no more than two commands, change the file permissions from\n\n```bash\n----------\n```\n\nto\n\n```bash\n-rw-rw--wx\n```\n\nNotice also that we here gave everyone writing permission to the file, that means that ANYONE can write to the file. Not very safe.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ chmod ug+rw filename  \n$ chmod o=wx filename'))\n```\n\n## Symbolic links\n### Files\n\nMuch like a windows user has a shortcut on his desktop to *WorldOfWarcraft.exe*, being able to create links to files or directories is good to know in Linux. An important thing to remember about symbolic links is that they are not updated, so if you or someone else moves or removes the original file/directory the link will stop working.\n\nMake sure you are standing in the directory **`r paste0('/proj/',upid,'/nobackup/username/advlinux')`**. Then remove our old file and directory.\n\n::: {.alert .alert-danger}\n**{{< fa skull-crossbones >}} Danger**\n\n`rm -r *` permanently removes all folder and subfolders from where you are standing. Be extremely careful when using this. Always double check current working directory or path.\n:::\n\n```bash\n$ rm -r *\n```\n\nNow that the directory is empty, let's make a new folder and a new file in that folder.\n\n```bash\n$ mkdir stuff\n$ touch stuff/linkfile\n```\n\nLets put some information into the file, just put some text, anything, like \"slartibartfast\" or something.\n\n```bash\n$ nano stuff/linkfile\n```\nNow let's create a link to this file in our original folder. **`ln`** stands for link and **`-s`** makes it symbolic. The other options are not in the scope of this course, but feel free to read about them on your own, https://stackoverflow.com/a/29786294\n\n```bash\n$ ln -s stuff/linkfile\n$ ls -l\n\ntotal 8\nlrwxr-xr-x  1 S_D  staff    14B Sep 21 15:38 linkfile -> stuff/linkfile\ndrwxr-xr-x  3 S_D  staff   102B Sep 21 15:36 stuff\n```\n\nNotice that we see the type of the file is `l`, for symbolic link, and that we have a pointer after the links name for where the link goes, `-> stuff/linkfile`.\n\nIf want you to change the information in the file using the link file, then you should change the information in the original file.\n\n{{< fa clipboard-list >}} Change the information using the original file, then check the link. Has the information changed in the original file and the linked file?\n\n{{< fa clipboard-list >}} Now move or delete the original file. What happens to the link? What information is there now if you open the link?\n\n{{< fa clipboard-list >}} Now create a new file in stuff/ with exactly the same name that your link file is pointing too with new information in it. What happens now? Is the link still broken? What is the content of the linked file now?\n\n\n### Directories\n\nNow let's create a link to a directory. Lets clean our workspace.\n\n```bash\n$ rm -r *\n```\n\nAnd create a directory three, arbitrarily, two directories away. The `-p` option to mkdir will make it create all 3 directories as needed. Without it, it would crash saying it can't create `three` because the directory `two` does not exist. \n\n```bash\n$ mkdir -p one/two/three\n```\n\nNow let's enter the directory and create some files there.\n\n```bash\n$ cd one/two/three\n$ touch a b c d e\n$ ls -lh\n\ntotal 0\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 a\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 b\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 c\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 d\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 e\n```\n\nReturn to our starting folder and create a symbolic link to folder three.\n\n```bash\n$ cd ../../..\n$ ln -s one/two/three\n$ ls -lh\n\ntotal 8\ndrwxr-xr-x  3 S_D  staff   102B Sep 21 16:11 one\nlrwxr-xr-x  1 S_D  staff    13B Sep 21 16:13 three -> one/two/three\n```\n\nOnce again, we see that it is correctly identified as a symbolic link, `l`, that it's default name is the same as the directory it is pointing to, same as the files link had the same name as the file by default previously, and that we have the additional pointer after the links name showing us where it's going.\n\n{{< fa clipboard-list >}} Run `ls` and `cd` on the link. Does it act just as if you were standing in directory two/ performing the very same actions on three/?\n\n{{< fa clipboard-list >}} After entering the link directory using `cd`, go back one step using `cd ..`, where do you end up?\n\nMoving, deleting or renaming the directory would, just like in the case with the file, break the link.\n\n## Grep\n\nSome files can be so large that opening it in a program would be very hard on your computer. It could be a file containing biological data, it could be a log file of a transfer where we want check for any errors. No matter the reason, a handy tool to know is the `grep` command.\n\n`grep` searches for a specific string in one or more files. Case sensitive/insensitive or regular expressions work as well.\n\nLet's start, as always, by cleaning our directory.\n\n```bash\n$ rm -r *\n```\n\nThen let's create a file with some text in it that we can work with. I have supplied some great text below.\n\n```bash\n$ nano textfile\n\nCats sleep anywhere, any table, any chair.\nTop of piano, window-ledge, in the middle, on the edge.\nOpen draw, empty shoe, anybody's lap will do.\nFitted in a cardboard box, in the cupboard with your frocks.\nAnywhere! They don't care! Cats sleep anywhere.\n```\n\nNow let's see how the grep command works. The syntax is:\n\n```bash\ngrep \"string\" filename/filepattern\n```\n\nSome examples for you to try and think about:\n\n```bash\n$ grep \"Cat\" textfile\n$ grep \"cat\" textfile\n```\n\nAs you can see the last one did not return any results. Add a `-i` for case insensitive search.\n\n```bash\n$ grep -i \"cat\" textfile\n```\n\nNow let's copy the file and check both of them together by matching a pattern for the filenames.\n\n```bash\n$ cp textfile textcopy\n$ grep \"Cat\" text*\n```\n\nThe `*` will ensure that any file starting with **text** and then anything following will be searched. This example would perhaps be more real if we had several text files with different texts and we were looking for a specific string in any of them.\n\nCopy the file sample_1.sam to your folder using the command below\n\n```bash\n$ cp /sw/courses/ngsintro/linux/linux_additional-files/sample_1.sam .\n```\n\n{{< fa clipboard-list >}} Use `grep` to search in the file for a specific string of nucleotides, for example:\n\n```bash\n$ grep \"TACCACCGAAATCTGTGCAGAGGAGAACGCAGCTCCGCCCTCGCGGTGCTCTCCGGGTCTGTGCTGAGGAG\" sample_1.sam\n```\n\n{{< fa clipboard-list >}} Try with shorter sequences. When do you start getting lots of hits? This file is only a fraction of a genome, you would have gotten many times more hits doing this to a complete many GB large sam file.\n\n{{< fa clipboard-list >}} Use `grep` to find all lines with **chr1** in them. This output is too much to be meaningful. Send it to a file (`>`) where you have now effectively stored all the chromosome 1 information.\n\n## Piping\n\nA useful tool in linux environment is the use of pipes. What they essentially do is connect the first command to the second command and the second command to the third command etc for as many commands as you want or need.\n\nThis is often used in UPPMAX jobs and other analysis as there are three major benefits. The first is that you do not have to stand in line to get a core or a node twice. The second is that you do not generate intermediary data which will clog your storage, you go from start file to result. The third is that it may actually be faster.\n\nThe pipe command has this syntax\n\n```bash\ncommand 1 | command 2\n```\n\nThe `|` is the pipe symbol (on mac keyboard alt+7), signifying that whatever output usually comes out of command 1 should instead be directly sent to command 2 and output in the manner that command 2 inputs.\n\nIn a hypothetical situation you have a folder with hundreds of files and you know the file you are looking for is very large but you can't remember its name.\n\nLet's do a `ls -l` in the `/etc` directory and pipe the output to be sorted by file size. `-n` means we are sorting numerically and not alphabetically, `-k 5` says *look at the fifth column of output*, which happens to be the file size of `ls` command.\n\n```bash\n$ ls -l /etc | sort -k 5 -n\n```\n\nAn example use would be to align a file and directly send the now aligned file to be converted into a different format that may be required for another part of the analysis.\n\nThe next step requires us to use a bioinformatics software called **samtools**. To be able to use this program we first have to load the module for it. We will cover this in the UPPMAX lectures, so if you are a bit too fast for you own good, you will just have to type this command:\n\n```bash\n$ module load bioinfo-tools samtools\n```\n\nHere is an example where we convert the samfile to a bamfile (**`-Sb`** literally means the input is **S**am and to output in **b**am) and pipe it to immediately get sorted, not even creating the unsorted bamfile intermediary. Notice that samtools is made to take the single `-` after samtools sort as the position of the piped data from samtools view.\n\n```bash\n$ samtools view -bS sample_1.sam | samtools sort - -o outbam\n```\n\nThis should have generated a file called **outbam.bam** in your current folder. We will have some more examples of pipes in the next section.\n\n## Word Count\n\n**`wc`** for **W**ord **C**ount is a useful command for counting the number of occurrences of a word in a file. This is easiest explained with an example.\n\nLet's return to our **sample_1.sam**.\n\n```bash\n$ wc sample_1.sam\n233288 3666760 58105794 sample_1.sam\n```\n\nThis can be interpreted like this:\n\nNumber of lines = 233288   \nNumber of words = 3666760  \nNumber of characters = 58105794  \n\nTo make this more meaningful, let's use the pipes and `grep` command seen previously to see how many lines and how many times the string of nucleotides `CATCATCAT` exist in this file.\n\n```bash\n$ grep \"CATCATCAT\" sample_1.sam | wc\n60  957 15074\n```\n\nTo see only the line count you can add `-l` after `wc` and to count only characters **-m**.\n\n{{< fa clipboard-list >}} Output only the amount of lines that have **chr1** in them from sample_1.sam.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ grep \"chr1\" sample_1.sam | wc -l'))\n```\n\n{{< fa clipboard-list >}} Count the lines containing `CATCATCAT` in the outbam.bam file.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ samtools view outbam.bam | grep \"CATCATCAT\" | wc -l'))\n```\n\n## Bonus exercise 1\n\nThese are some harder assignments, so don't worry about it if you didn't have time to do it.\n\nLets look at `grep` and use some regular expressions http://www.cheatography.com/davechild/cheat-sheets/regular-expressions/\n\n{{< fa clipboard-list >}} From file **sample_1.sam** find all lines that start with `@` and put them in a file called **at.txt**.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ grep \"^@\" sample_1.sam > at.txt'))\n```\n\n{{< fa clipboard-list >}} Find all the lines that end with at least 3 numbers from **at.txt**.\n{{< fa lightbulb >}} **Sometimes**, you have to escape {} with \\\\{\\\\})\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ grep \"[0-9]\\\\{3\\\\}$\" sample_1.sam'))\n```\n\n## Bonus exercise 2\n\n`[sed](http://www.grymoire.com/Unix/Sed.html)` is a handy tool to replace strings in files.\n\n{{< fa clipboard-list >}} You have realized that all the chromosomes have been misnamed as **chr3** when they should be **chr4**. Use `sed` to replace **chr3** with **chr4** in **sample_1.sam** and output it to **sample_2.sam**.\n\n{{< fa lightbulb >}} The solution to this replaces the first instance on each line of chr3. What if we have multiple instances? What if we had wanted to replace **chr1**? This would effect chr10-19 as well! There are many things to consider :).\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ sed \"s/chr1/chr2/\" sample_1.sam > sample_2.sam'))\n```\n\n## Bonus exercise 3\n\nBash loops are great for moving or renaming multiple files as well as many many other uses.\n\nCreate a couple of files as seen below\n\n```bash\n$ touch one.bam two.sam three.bam four.sam five.bam six.sam\n```\n\n{{< fa clipboard-list >}} All the files are actually in bam format. What a crazy mistake! Create a bash loop that changes all files ending in **.sam** to end with **.bam** instead.\n\n{{< fa lightbulb >}} The bash loop syntax is this:\n\n```bash\n$ for _variable_ in _pattern_; do _command with $variable_; done\n```\n\n{{< fa lightbulb >}} To rename file1 to file2 you write this:\n\n```bash\n$ mv file1 file2\n```\n\nwhich effectively is the same thing as\n\n```bash\n$ cp file1 file2\n$ rm file1\n```\n\n{{< fa lightbulb >}} Ponder how this can be used to your advantage:\n\n```bash\n$ i=filename\n$ echo ${i/name}stuff\nfilestuff\n```\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ for f in *.sam\ndo\n  mv $f ${f/.sam}.bam;\ndone'))\n```\n","srcMarkdownNoYaml":"\n\n```{r,eval=TRUE,include=FALSE}\nlibrary(yaml)\nlibrary(here)\nupid <- yaml::read_yaml(here(\"_quarto.yml\"))$uppmax_project\n```\n\n::: {.callout-note}\nIn code blocks, the dollar sign (`$`) is not to be printed. The dollar sign is usually an indicator that the text following it should be typed in a terminal window.\n:::\n\n## Ownership & Permissions\n\nAs Linux can be a multi-user environment it is important that files and directories can have different owners and permissions to keep people from editing or executing your files.\n\n### Owners\n\nThe permissions are defined separately for **users**, **groups** and **others**.\n\nThe **user** is the username of the person who owns the file. By default the user who creates a file will become its owner. The **group** is a group of users that co-own the file. They will all have the same permissions to the file. This is useful in any project where a group of people are working together. The **others** is quite simply everyone else's permissions.\n\n### Permissions\n\nThere are four permissions that a file or directory can have. Note the one character designations/flags, **`r`**,**`w`**,**`x`**  and  **`-`**.\n\nIn all cases, if the file or directory has the flag it means that it is enabled.\n\n**Read: `r`**\n\nFile: Whether the file can be opened and read.  \nDirectory: Whether the contents of the directory can be listed.\n\n**Write: `w`**\n\nFile: Whether the file can be modified. (*Note that for renaming or deleting a file you need additional directory permissions.*)  \nDirectory: Whether the files in the directory can be renamed or deleted.\n\n**Execute: `x`**\n\nFile: Whether the file can be executed as a program or shell script.  \nDirectory: Whether the directory can be entered using `cd`.\n\n**No permissions: `-`**\n\n## Interpreting permissions\n\nMake an empty directory we can work in and make a file.\n\n```{r,echo=FALSE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ cd /proj/',upid,'/nobackup/username\n$ mkdir advlinux\n$ cd advlinux\n$ touch  filename\n$ ls -lh\ntotal 0\n -rw-r--r-- 1 S_D staff 0B Sep 21 13:54 filename'))\n```\n\n(`-lh` means long and human readable, displaying more information about the files or directories in a human understandable format)\n\nThis shows us a cryptic line for each file/folder, where the columns are as following:\n\n```\n-rw-rw-r--   : permissions\n1            : number of linked hard-links\nS_D          : owner of the file\nstaff        : to which group this file belongs to\n0            : file size\nSep 21 13:54 : modification/creation date and time\nfilename     : file/directory name\n```\n\n\nThe first segment, `-rw-r--r--`, describes the ownerships and permissions of our newly created file. The very first character, in this case `-`, shows the file's type. It can be any of these:\n\n**`d`** = directory\n**`-`** = regular file\n**`l`** = symbolic link\n**`s`** = Unix domain socket\n**`p`** = named pipe\n**`c`** = character device file\n**`b`** = block device file\n\nAs expected the file we have just created is a regular file. Ignore the types other than directory, regular and symbolic link as they are outside the scope of this course.\n\nThe next nine characters, in our case `rw-r--r--`, can be divided into three groups consisting of three characters in order from left to right. In our case `rw-`, `r--` and `r--`. The first group designates the **users** permissions, the second the **groups** permissions and the third the **others** permissions. As you may have guessed the within group permissions are ordered, the first always designates read permissions, the second write and the third executability.\n\nThis translates our files permissions to say this `-rw-r--r--`:\n\n```\n- It is a regular file.\n- The user has read & write permission, but not execute.\n- The group has read permission but not write and execute.\n- Everyone else (other), have read permission but not write and execute.\n```\n\nAs another example, lets create a directory.\n\n```bash\n$ mkdir directoryname\n$ ls -lh\ntotal 0\ndrwxr-xr-x  2 S_D  staff    68B Sep 21 14:41 directoryname\n-rw-r--r--  1 S_D  staff     0B Sep 21 13:54 filename\n```\n\nAs you can see the first character correctly identifies it as **`d`**, a directory, and all user groups have **`x`**, execute permissions, to enter the directory by default.\n\n## Editing Ownership & Permissions\n\nThe command to set file permission is `chmod` which means **CH**ange **MOD**e. Only the owner can set file permissions.\n\n1. First you decide which group you want to set permissions for. User, **`u`**, group, **`g`**, other, **`o`**, or all three, **`a`**.\n2. Next you either add, **`+`**, remove, **`-`**, or wipe out previous and add new, **`=`**, permissions.\n3. Then you specify the kind of permission: **`r`**,**`w`**,**`x`**, or **`-`**.\n\nLets revisit our example file and directory to test this.\n\n```bash\n$ ls -lh\ntotal 0\ndrwxr-xr-x  2 S_D  staff    68B Sep 21 14:41 directoryname\n-rw-r--r--  1 S_D  staff     0B Sep 21 13:54 filename\n$ chmod a=x filename\n$ ls -lh\ntotal 0\ndrwxr-xr-x  2 S_D  staff    68B Sep 21 14:41 directoryname\n---x--x--x  1 S_D  staff     0B Sep 21 13:54 filename\n```\n\nAs you can see this affected all three, **`a`**, it wiped the previous permissions, **`=`**, and added an executable permission, **`x`**, to all three groups.\n\nTry some others both on the file and directory to get the hang of it.\n\n```bash\n$ chmod g+r filename\n$ chmod u-x filename\n$ chmod ug=rx filename\n$ chmod a=- filename\n$ chmod a+w directoryname\n```\n\n{{< fa clipboard-list >}} In no more than two commands, change the file permissions from\n\n```bash\n----------\n```\n\nto\n\n```bash\n-rw-rw--wx\n```\n\nNotice also that we here gave everyone writing permission to the file, that means that ANYONE can write to the file. Not very safe.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ chmod ug+rw filename  \n$ chmod o=wx filename'))\n```\n\n## Symbolic links\n### Files\n\nMuch like a windows user has a shortcut on his desktop to *WorldOfWarcraft.exe*, being able to create links to files or directories is good to know in Linux. An important thing to remember about symbolic links is that they are not updated, so if you or someone else moves or removes the original file/directory the link will stop working.\n\nMake sure you are standing in the directory **`r paste0('/proj/',upid,'/nobackup/username/advlinux')`**. Then remove our old file and directory.\n\n::: {.alert .alert-danger}\n**{{< fa skull-crossbones >}} Danger**\n\n`rm -r *` permanently removes all folder and subfolders from where you are standing. Be extremely careful when using this. Always double check current working directory or path.\n:::\n\n```bash\n$ rm -r *\n```\n\nNow that the directory is empty, let's make a new folder and a new file in that folder.\n\n```bash\n$ mkdir stuff\n$ touch stuff/linkfile\n```\n\nLets put some information into the file, just put some text, anything, like \"slartibartfast\" or something.\n\n```bash\n$ nano stuff/linkfile\n```\nNow let's create a link to this file in our original folder. **`ln`** stands for link and **`-s`** makes it symbolic. The other options are not in the scope of this course, but feel free to read about them on your own, https://stackoverflow.com/a/29786294\n\n```bash\n$ ln -s stuff/linkfile\n$ ls -l\n\ntotal 8\nlrwxr-xr-x  1 S_D  staff    14B Sep 21 15:38 linkfile -> stuff/linkfile\ndrwxr-xr-x  3 S_D  staff   102B Sep 21 15:36 stuff\n```\n\nNotice that we see the type of the file is `l`, for symbolic link, and that we have a pointer after the links name for where the link goes, `-> stuff/linkfile`.\n\nIf want you to change the information in the file using the link file, then you should change the information in the original file.\n\n{{< fa clipboard-list >}} Change the information using the original file, then check the link. Has the information changed in the original file and the linked file?\n\n{{< fa clipboard-list >}} Now move or delete the original file. What happens to the link? What information is there now if you open the link?\n\n{{< fa clipboard-list >}} Now create a new file in stuff/ with exactly the same name that your link file is pointing too with new information in it. What happens now? Is the link still broken? What is the content of the linked file now?\n\n\n### Directories\n\nNow let's create a link to a directory. Lets clean our workspace.\n\n```bash\n$ rm -r *\n```\n\nAnd create a directory three, arbitrarily, two directories away. The `-p` option to mkdir will make it create all 3 directories as needed. Without it, it would crash saying it can't create `three` because the directory `two` does not exist. \n\n```bash\n$ mkdir -p one/two/three\n```\n\nNow let's enter the directory and create some files there.\n\n```bash\n$ cd one/two/three\n$ touch a b c d e\n$ ls -lh\n\ntotal 0\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 a\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 b\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 c\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 d\n-rw-r--r--  1 S_D  staff     0B Sep 21 16:11 e\n```\n\nReturn to our starting folder and create a symbolic link to folder three.\n\n```bash\n$ cd ../../..\n$ ln -s one/two/three\n$ ls -lh\n\ntotal 8\ndrwxr-xr-x  3 S_D  staff   102B Sep 21 16:11 one\nlrwxr-xr-x  1 S_D  staff    13B Sep 21 16:13 three -> one/two/three\n```\n\nOnce again, we see that it is correctly identified as a symbolic link, `l`, that it's default name is the same as the directory it is pointing to, same as the files link had the same name as the file by default previously, and that we have the additional pointer after the links name showing us where it's going.\n\n{{< fa clipboard-list >}} Run `ls` and `cd` on the link. Does it act just as if you were standing in directory two/ performing the very same actions on three/?\n\n{{< fa clipboard-list >}} After entering the link directory using `cd`, go back one step using `cd ..`, where do you end up?\n\nMoving, deleting or renaming the directory would, just like in the case with the file, break the link.\n\n## Grep\n\nSome files can be so large that opening it in a program would be very hard on your computer. It could be a file containing biological data, it could be a log file of a transfer where we want check for any errors. No matter the reason, a handy tool to know is the `grep` command.\n\n`grep` searches for a specific string in one or more files. Case sensitive/insensitive or regular expressions work as well.\n\nLet's start, as always, by cleaning our directory.\n\n```bash\n$ rm -r *\n```\n\nThen let's create a file with some text in it that we can work with. I have supplied some great text below.\n\n```bash\n$ nano textfile\n\nCats sleep anywhere, any table, any chair.\nTop of piano, window-ledge, in the middle, on the edge.\nOpen draw, empty shoe, anybody's lap will do.\nFitted in a cardboard box, in the cupboard with your frocks.\nAnywhere! They don't care! Cats sleep anywhere.\n```\n\nNow let's see how the grep command works. The syntax is:\n\n```bash\ngrep \"string\" filename/filepattern\n```\n\nSome examples for you to try and think about:\n\n```bash\n$ grep \"Cat\" textfile\n$ grep \"cat\" textfile\n```\n\nAs you can see the last one did not return any results. Add a `-i` for case insensitive search.\n\n```bash\n$ grep -i \"cat\" textfile\n```\n\nNow let's copy the file and check both of them together by matching a pattern for the filenames.\n\n```bash\n$ cp textfile textcopy\n$ grep \"Cat\" text*\n```\n\nThe `*` will ensure that any file starting with **text** and then anything following will be searched. This example would perhaps be more real if we had several text files with different texts and we were looking for a specific string in any of them.\n\nCopy the file sample_1.sam to your folder using the command below\n\n```bash\n$ cp /sw/courses/ngsintro/linux/linux_additional-files/sample_1.sam .\n```\n\n{{< fa clipboard-list >}} Use `grep` to search in the file for a specific string of nucleotides, for example:\n\n```bash\n$ grep \"TACCACCGAAATCTGTGCAGAGGAGAACGCAGCTCCGCCCTCGCGGTGCTCTCCGGGTCTGTGCTGAGGAG\" sample_1.sam\n```\n\n{{< fa clipboard-list >}} Try with shorter sequences. When do you start getting lots of hits? This file is only a fraction of a genome, you would have gotten many times more hits doing this to a complete many GB large sam file.\n\n{{< fa clipboard-list >}} Use `grep` to find all lines with **chr1** in them. This output is too much to be meaningful. Send it to a file (`>`) where you have now effectively stored all the chromosome 1 information.\n\n## Piping\n\nA useful tool in linux environment is the use of pipes. What they essentially do is connect the first command to the second command and the second command to the third command etc for as many commands as you want or need.\n\nThis is often used in UPPMAX jobs and other analysis as there are three major benefits. The first is that you do not have to stand in line to get a core or a node twice. The second is that you do not generate intermediary data which will clog your storage, you go from start file to result. The third is that it may actually be faster.\n\nThe pipe command has this syntax\n\n```bash\ncommand 1 | command 2\n```\n\nThe `|` is the pipe symbol (on mac keyboard alt+7), signifying that whatever output usually comes out of command 1 should instead be directly sent to command 2 and output in the manner that command 2 inputs.\n\nIn a hypothetical situation you have a folder with hundreds of files and you know the file you are looking for is very large but you can't remember its name.\n\nLet's do a `ls -l` in the `/etc` directory and pipe the output to be sorted by file size. `-n` means we are sorting numerically and not alphabetically, `-k 5` says *look at the fifth column of output*, which happens to be the file size of `ls` command.\n\n```bash\n$ ls -l /etc | sort -k 5 -n\n```\n\nAn example use would be to align a file and directly send the now aligned file to be converted into a different format that may be required for another part of the analysis.\n\nThe next step requires us to use a bioinformatics software called **samtools**. To be able to use this program we first have to load the module for it. We will cover this in the UPPMAX lectures, so if you are a bit too fast for you own good, you will just have to type this command:\n\n```bash\n$ module load bioinfo-tools samtools\n```\n\nHere is an example where we convert the samfile to a bamfile (**`-Sb`** literally means the input is **S**am and to output in **b**am) and pipe it to immediately get sorted, not even creating the unsorted bamfile intermediary. Notice that samtools is made to take the single `-` after samtools sort as the position of the piped data from samtools view.\n\n```bash\n$ samtools view -bS sample_1.sam | samtools sort - -o outbam\n```\n\nThis should have generated a file called **outbam.bam** in your current folder. We will have some more examples of pipes in the next section.\n\n## Word Count\n\n**`wc`** for **W**ord **C**ount is a useful command for counting the number of occurrences of a word in a file. This is easiest explained with an example.\n\nLet's return to our **sample_1.sam**.\n\n```bash\n$ wc sample_1.sam\n233288 3666760 58105794 sample_1.sam\n```\n\nThis can be interpreted like this:\n\nNumber of lines = 233288   \nNumber of words = 3666760  \nNumber of characters = 58105794  \n\nTo make this more meaningful, let's use the pipes and `grep` command seen previously to see how many lines and how many times the string of nucleotides `CATCATCAT` exist in this file.\n\n```bash\n$ grep \"CATCATCAT\" sample_1.sam | wc\n60  957 15074\n```\n\nTo see only the line count you can add `-l` after `wc` and to count only characters **-m**.\n\n{{< fa clipboard-list >}} Output only the amount of lines that have **chr1** in them from sample_1.sam.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ grep \"chr1\" sample_1.sam | wc -l'))\n```\n\n{{< fa clipboard-list >}} Count the lines containing `CATCATCAT` in the outbam.bam file.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ samtools view outbam.bam | grep \"CATCATCAT\" | wc -l'))\n```\n\n## Bonus exercise 1\n\nThese are some harder assignments, so don't worry about it if you didn't have time to do it.\n\nLets look at `grep` and use some regular expressions http://www.cheatography.com/davechild/cheat-sheets/regular-expressions/\n\n{{< fa clipboard-list >}} From file **sample_1.sam** find all lines that start with `@` and put them in a file called **at.txt**.\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ grep \"^@\" sample_1.sam > at.txt'))\n```\n\n{{< fa clipboard-list >}} Find all the lines that end with at least 3 numbers from **at.txt**.\n{{< fa lightbulb >}} **Sometimes**, you have to escape {} with \\\\{\\\\})\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ grep \"[0-9]\\\\{3\\\\}$\" sample_1.sam'))\n```\n\n## Bonus exercise 2\n\n`[sed](http://www.grymoire.com/Unix/Sed.html)` is a handy tool to replace strings in files.\n\n{{< fa clipboard-list >}} You have realized that all the chromosomes have been misnamed as **chr3** when they should be **chr4**. Use `sed` to replace **chr3** with **chr4** in **sample_1.sam** and output it to **sample_2.sam**.\n\n{{< fa lightbulb >}} The solution to this replaces the first instance on each line of chr3. What if we have multiple instances? What if we had wanted to replace **chr1**? This would effect chr10-19 as well! There are many things to consider :).\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ sed \"s/chr1/chr2/\" sample_1.sam > sample_2.sam'))\n```\n\n## Bonus exercise 3\n\nBash loops are great for moving or renaming multiple files as well as many many other uses.\n\nCreate a couple of files as seen below\n\n```bash\n$ touch one.bam two.sam three.bam four.sam five.bam six.sam\n```\n\n{{< fa clipboard-list >}} All the files are actually in bam format. What a crazy mistake! Create a bash loop that changes all files ending in **.sam** to end with **.bam** instead.\n\n{{< fa lightbulb >}} The bash loop syntax is this:\n\n```bash\n$ for _variable_ in _pattern_; do _command with $variable_; done\n```\n\n{{< fa lightbulb >}} To rename file1 to file2 you write this:\n\n```bash\n$ mv file1 file2\n```\n\nwhich effectively is the same thing as\n\n```bash\n$ cp file1 file2\n$ rm file1\n```\n\n{{< fa lightbulb >}} Ponder how this can be used to your advantage:\n\n```bash\n$ i=filename\n$ echo ${i/name}stuff\nfilestuff\n```\n\n```{r,echo=FALSE,accordion=TRUE,class.output=\"bash\",comment='',results='markup'}\ncat(paste0('$ for f in *.sam\ndo\n  mv $f ${f/.sam}.bam;\ndone'))\n```\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"kable","error":false,"eval":true,"cache":null,"freeze":"auto","echo":true,"output":true,"warning":false,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"message":false,"engine":"knitr"},"render":{"keep-tex":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"left","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"wrap","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true,"format-links":true},"pandoc":{"standalone":false,"wrap":"none","default-image-extension":"png","to":"html","filters":["../../assets/custom.lua","reveal-header","lightbox"],"include-in-header":["../../assets/fonts/head.html"],"toc":true,"toc-depth":4,"number-sections":true,"output-file":"lab_linux_permissions.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.3.433","bibliography":["../../references.bib"],"csl":"../../apa.csl","knitr":{"opts_chunk":{"results":"hold"}},"uppmax_project":"snic2023-xx-xxxx","nsc_project":"snic2023-xx-xxxx","uppmax_res_1":"snic2023-xx-xxxx_1","uppmax_res_2":"snic2023-xx-xxxx_2","uppmax_res_3":"snic2023-xx-xxxx_3","uppmax_res_4":"snic2023-xx-xxxx_4","uppmax_res_5":"snic2023-xx-xxxx_5","location":"uppsala","assistants":["AJ: Anna Johansson","BV: Björn Viklund","DA: Dag Ahren","FB: Franziska Bonath","JH: Jason Hill","JB: Joakim Bygdell","JA: Juliana Assis","KL: Katarina Lejonlid","KB: Kristina Benevides","LK: Linda Köhn","LV: Louella Vasquez","MD: Martin Dahlö","MG: Maxime Garcia","ML: Malin Larsson","MM: Markus Mayrhofer","NN: Nina Norgren","OVP: Olga Vinnere Pettersson","PA: Prasoon Agarwal","PP: Paul Pyl","RF: Roy Francis","VVH: Vincent van Hoef","SD: Sebastian DiLorenzo"],"schedule_message":"Coffee breaks are planned for approximately 10:00 and 14:30 every day.","colors":{"primary":"#95b540","secondary":"#E9F2D1"},"packages":{"packages_cran_student":["BiocManager","remotes","dplyr","ggplot2","pheatmap","stringr","tidyr"],"packages_bioc_student":["DESeq2","edgeR","goseq","GO.db","org.Mm.eg.db","reactome.db"],"packages_github_student":null,"packages_cran_repo":["bookdown","captioner","here","htmlTable","knitr","leaflet","lubridate","markdown","pagedown","yaml"],"packages_bioc_repo":null,"packages_github_repo":null},"quarto-required":">=1.2.2","theme":"../../assets/css/custom.scss","smooth-scroll":true,"toc-location":"right","number-depth":4,"code-copy":true,"title-block-banner":"#E9F2D1","callout-icon":false,"date":"last-modified","date-format":"DD-MMM-YYYY","lightbox":{"match":"auto"},"title":"File permissions","subtitle":"Ownership and permissions for files and folders","author":"Martin Dahlö"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html","revealjs"]}