{
  "hash": "ff7fb03c70694080ab8f77079fb9b88e",
  "result": {
    "markdown": "---\ntitle: 'Advanced Linux'\nsubtitle: 'Variables and Loops'\nauthor: 'Martin Dahlö'\nformat: html\n---\n\n\n\n\n::: {.callout-note}\nIn code blocks, the dollar sign (`$`) is not to be printed. The dollar sign is usually an indicator that the text following it should be typed in a terminal window.\n:::\n\n## Connect to UPPMAX\n\nThe first step of this lab is to open a ssh connection to UPPMAX. Please refer to [**Connecting to UPPMAX**](topics/other/lab_connect.html) for instructions. Once connected to UPPMAX, return here and continue reading the instructions below.\n\n## Logon to a node\n\nUsually you would do most of the work in this lab directly on one of the login nodes at UPPMAX, but we have arranged for you to have one core each for better performance. This was covered briefly in the lecture notes.\n\nCheck which node you got when you booked resources this morning (replace **username** with your UPPMAX username)\n\n```bash\n$ squeue -u username\n```\n\nshould look something like this\n\n```bash\ndahlo@rackham2 work $ squeue -u dahlo\n             JOBID PARTITION     NAME     USER ST       TIME  NODES NODELIST(REASON)\n           3132376      core       sh    dahlo  R       0:04      1 r292\ndahlo@rackham2 work $\n```\n\nwhere **r292** is the name of the node I got (yours will probably be different).\nNote the numbers in the Time column. They show for how long the job has been running. When it reaches the time limit you requested (7 hours in this case) the session will shut down, and you will lose all unsaved data. Connect to this node from within UPPMAX.\n\n```bash\n$ ssh -Y r292\n```\n\nIf the list is empty you can run the allocation command again and it should be in the list:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(paste0(\"$ salloc -A \",upid,\" -t 03:30:00 -p core -n 1 --no-shell &\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n$ salloc -A snic2023-xx-xxxx -t 03:30:00 -p core -n 1 --no-shell &\n```\n:::\n:::\n\n\n{{< fa lightbulb >}} There is a UPPMAX specific tool called `jobinfo` that supplies the same kind of information as `squeue` that you can use as well (`$ jobinfo -u username`).\n\n## First things first\n\nLet's make sure nano has **syntax highlighting** enabled. What that will do is to paint the boring code in pretty colors, making it much easier to read it. See the difference for yourself by first looking at this file before you enable it:\n\n```bash\n$ nano /sw/uppmax/bin/projplot\n```\n\nClose down nano when you have seen how boing it looks without colors by pressing `ctrl+x`. Now, let's enable syntax highlighting. To do this, we will simply tell nano to include the syntax highlighting instructions from a bunch of files that are already installed at uppmax. Run this command to do just that:\n\n```bash\n$ find /usr/share/nano/ -iname \"*.nanorc\" -exec echo include {} \\; >> ~/.nanorc\n```\n\nThis command will put one line per language instructions (~30 of them, located in `/usr/share/nano`), into the nano autostart file (`~/.nanorc`) and put the word 'include' infront of each file name. That will make nano include the instructions from each of those files whenever it starts. Now have a look at the same file as before and enjoy the colors:\n\n```bash\n$ nano /sw/uppmax/bin/projplot\n```\n\nThen close nano and continue with the lab.\n\n## Copy files for lab\n\nNow, you will need some files. To avoid all the course participants editing the same file all at once, undoing each other's edits, each participant will get their own copy of the needed files. The files are located in the folder `/sw/courses/ngsintro/linux/linux_advanced/`.\n\nIf you for some reason have problems copying the files, or if you are not on UPPMAX when running this lab, you can download these files [here](assets/linux_advanced.tar.gz). You can unpack the file using the command `tar -xzvf linux_advanced.tar.gz` once you have downloaded it. After unpacking, continue the lab from step 4.\n\nNext, copy the lab files from this folder. `-r` means recursively, which means all the files including sub-folders of the source folder. Without it, only files directly in the source folder would be copied, NOT sub-folders and files in sub-folders.\n\n{{< fa lightbulb >}} Remember to use tab-complete to avoid typos and too much writing.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n$ cp -r <source> <destination>\n$ cp -r /sw/courses/ngsintro/linux/linux_advanced /proj/snic2023-xx-xxxx/nobackup/username\n```\n:::\n:::\n\n\nHave a look in `/proj/snic2023-xx-xxxx/nobackup/username/linux_advanced`.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n$ cd /proj/snic2023-xx-xxxx/nobackup/username/linux_advanced\n```\n:::\n:::\n\n\n```bash\n$ ll\n```\n\nIf you see files, the copying was successful.\n\n\n## Using variables\n\nVariables are like small notes you write stuff on. If you want to save the value of something to be able to use it later, variables is the way to go. Let's try assigning values to some variables and see how we use them.\n\n```bash\n$ a=5\n```\n\nNow the values 5 is stored in the variable named `a`. To use the variable we have to put a `$` sign in front of it so that bash knows we are referring to the variable `a` and not just typing the letter `a`. To see the result of using the variable, we can use the program `echo`, which prints whatever you give it to the terminal.\n\n```bash\n$ echo print this text to the terminal\n$ echo \"you can use quotes if you want to\"\n```\n\nAs you see, all the words you give it are printed just the way they are. Try putting the variable somewhere in the text.\n\n```bash\n$ echo Most international flights leave from terminal $a at Arlanda airport\n```\n\nBash will see that you have a variable there and will replace the variable name with the value the variable have before sending the text to echo. If you change the value of `a` and run the exact command again you will see that it changes.\n\n```bash\n$ a=\"five\"\n$ echo Most international flights leave from terminal $a at Arlanda airport\n```\n\nSo without changing anything in the echo statement, we can make it output different things, all depending on the value of the variable `a`. This is one of the main points of using variables, that you don't have to change the code or script but you can still make it behave differently depending on the values of the variables.\n\nYou can also do mathematics with variables, but we have to tell bash that we want to do calculations first. We do this by wrapping the calculations inside a dollar sign (telling bash it's a variable) and double parentheses, i.e. `$((5+5))`.\n\n```bash\n$ a=4\n$ echo $a squared is $(($a*$a))\n```\n\n{{< fa clipboard-list >}} Write a echo command that will print out the volume of a [rectangular cuboid](https://www.mathsisfun.com/cuboid.html), with the side lengths specified by variables named `x`, `y`, and `z`. To see that it works correctly, the volume of a rectangular cuboid with sides 5,5,5 is 125, and for 4,5,10 is 200. *Give it a couple of tries on your own first. If you get completely stuck you can see a suggested solution below.*\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n$ x=4\n$ y=5\n$ z=10\n$ echo The volume of the rectangular cuboid with the sides $x,$y,$z is $(($x*$y*$z)).\n```\n:::\n:::\n\n\n## Exercises\n\nFirst off, let's open another terminal to UPPMAX so that you have 2 of them open. Scripting is a lot easier if you have one terminal on the command line ready to run commands and test things, and another one with a text editor where you write the actual code. That way you will never have to close down the text editor when you want to run the script you are writing on, and then open it up again when you want to continue editing the code.\n\nSo open a new terminal window, connect it to UPPMAX and then connect it to the node you have booked. Make sure both terminals are in the `/proj/snic2023-xx-xxxx/nobackup/username/linux_advanced` directory, and start editing a new file with gedit or nano where you write your script. Name the file whatever you want, but in the examples I will refer to it as `loop_01.sh`. Write your loops to this file (or create a new file for each new example) and test run it in the other terminal.\n\n**NOTE:** If you get error messages like `(gedit:27463): dconf-WARNING **: 10:59:00.575: failed to commit changes to dconf: Failed to execute child process “dbus-launch” (No such file or directory)`, and if you can't change any preferences, you can try starting gedit through the graphical menu in ThinLic instead. If you are using the Xfce desktop environment you should have a start-menu-like button at the top-left of the screen named `Applications`, or if you right-click somewhere on the desktop you should find it in the context menu that pops up. In the `Applications` menu, look in the category `Accessories` and you should find a program called `Text editor` which will start gedit *(hopefully without the errors).\n\nThe most simple loops are the ones that loop over a predefined list. You saw examples of this in the lecture slides, for example:\n\n```bash\nfor i in \"Print these words\" one by one;\ndo\n    echo $i\ndone\n```\n\nwhich will print the value of `$i` in each iteration of the loop. Write this loop in the file you are editing with `gedit`/`nano`, save the file, and then run it in the other terminal you have open.\n\n```bash\n$ bash loop_01.sh\n```\n\nAs you see, the words inside the quotation marks are treated as a single unit, unlike the words after. You can also iterate over numbers, so erase the previous loop you wrote and try this instead:\n\n```bash\nfor number in 1 2 3;\ndo\n    echo $number\ndone\n```\n\nIf everything worked correctly you should have gotten the numbers `1 2 3` printed to the screen. As you might guess, this way of writing the list of numbers to iterate over will not be usable once you have more than 10 or so numbers you want to loop over. Fortunately, the creators of bash (and most other computer languages) saw this problem coming a mile away and did something about it. To quickly create a list of numbers in bash, you can use something called a sequence expression to create the list for you.\n\n```bash\nfor whatevernameyouwant in {12..72};  \ndo  \n    echo $whatevernameyouwant  \ndone  \n```\n\n### Exercise 1\n\n{{< fa clipboard-list >}} Let's say it's New Year's Eve and you want to impress your friends with a computerized countdown of the last 10 seconds of the year (don't we all?).\n\n::: {.callout-tip}\nStart off with getting a loop to count down from 10 to 0 first. Notice how fast the computer counts? That won't do if it's seconds we want to be counting down. Try looking the man page for the `sleep` command (`man sleep`) and figure out how to use it. The point of using `sleep` is to tell the computer to wait for 1 second after printing the number, instead of rushing to the next iteration in the loop directly. Try to implement this on your own.\n:::\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# declare the values the loop will loop over\nfor secondsToGo in {10..0};\ndo\n    # print out the current number\n    echo $secondsToGo\n\n    # sleep for 1 second\n    sleep 1\n\ndone\n\n# Declare the start of a new year in a festive manner\necho Happy New Year everyone!!\n```\n:::\n:::\n\n\n### Exercise 2\n\nLet's try to do something similar to the example in the lecture slides, to run the same commands on multiple files. In the Introduction to UPPMAX, we learned how to use samtools to convert BAM files to SAM files so that humans can read them.\nIn real life you will never do this, instead you will most likely always do it the other way around. SAM files take up ~4x more space on the hard drive compared to the same file in BAM format, so as soon as you see a SAM file you should convert it to a BAM file instead to conserve hard drive space. If you have many SAM files that needs converting you don't want to sit there and type all the commands by hand like a pleb.\n\n{{< fa clipboard-list >}} Write a script that converts all the SAM files in a specified directory to BAM files. Incidentally, you can find 50 SAM files in need of conversion in the folder called `sam` in the folder you copied to your folder earlier in this lab (`/proj/snic2023-xx-xxxx/nobackup/username/linux_advanced/sam`). Bonus points if you make the program take the specified directory as an argument, and another bonus point if you get the program to name the resulting BAM file to the same name as the SAM file but with a .bam ending instead.\n\n::: {.callout-tip}\nRemember that you have to load the samtools module to be able to run it. The way you get samtools to convert a SAM file to a BAM file is by typing the following command:\n\n```bash\nsamtools view -bS sample_1.sam > sample_1.bam\n```\n\nThe `-b` option tells samtools to output BAM format, and the `-S` option tells samtools that the input is in SAM format.\n\nRemember, Google is a good place to get help. If you get stuck, google \"bash remove file ending\" or \"bash argument to script\" and look for hits from [StackOverflow/StackExchange](https://stackoverflow.com/) or similar pages. There are always many different way to solve a problem. Try finding one you understand what they do and test if you can get them to work the way you want. If not, look for another solution and try that one instead.\n:::\n\nBasic, without bonus points:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# load the modules needed for samtools\nmodule load bioinfo-tools samtools/1.3\n\n# move to the SAM files directory to start with\ncd sam\n\n# use ls to get the list to iterate over\nfor file in *.sam;\ndo\n    # do the actual converting, just slapping on .bam at the end of the name\n    samtools view -bS $file > $file.bam\ndone\n```\n:::\n:::\n\n\nAdvanced, with bonus points:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# load the modules needed for samtools\nmodule load bioinfo-tools samtools/1.3\n\n# move to the SAM files directory to start with.\n# $1 contains the first argument given to the program\ncd $1\n\n# use ls to get the list to iterate over.\nfor file in *.sam;\ndo\n\n    # print a message to the screen so that the user knows what is happening.\n    # $(basename $file .sam) means that it will take the file name and remove .sam\n    # at the end of the name.\n    echo \"Converting $file to $(basename $file .sam).bam\"\n\n    # do the actual converting\n    samtools view -bS $file > $(basename $file .sam).bam\ndone\n```\n:::\n:::\n\n\n### Exercise 3\n\nLet's add a small thing to the exercise we just did. If there already exists a BAM file with the same name as the SAM file it's not necessary to convert it again. Let's use an `if` statement to check if the file already exists before we do the conversion.\n\nThe following `if` statement will check if a given filename exists, and prints a message depending on if it exists or not.\n\n```bash\nFILE=$1\n\nif [ -f $FILE ];\nthen\n   echo \"File $FILE exists.\"\nelse\n   echo \"File $FILE does not exist.\"\nfi\n```\n\nWhat we want to do is to check if the file **doesn't** exists. The way to do that is to invert the answer of the check if the file does exist. To do that in bash, and many other languages, is to use the exclamation mark, `!`, which in these kinds of logical situations means **NOT** or **the opposite of**.\n\n```bash\nFILE=$1\n\nif [ ! -f $FILE ];\nthen\n    echo \"File $FILE does not exist.\"\nfi\n```\n\n{{< fa clipboard-list >}} Now, modify the previous exercise to only do the conversion if a file with the intended name of the BAM file doesn't already exists. *i.e*; if you have `a.sam` and want to create a BAM file named `a.bam`, first check if `a.bam` already exists and only do the conversion if it does not exist.\n\nBasic:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# load the modules needed for samtools\nmodule load bioinfo-tools samtools/1.3\n\n# move to the SAM files directory to start with.\ncd sam\n\n# use ls to get the list to iterate over.\nfor file in *.sam;\ndo\n    # check if the intended output file does not already exists\n    if [ ! -f $file.bam ];\n    then\n        # do the actual converting, just slapping on .bam at the end of the name\n        samtools view -bS $file > $file.bam\n    fi\ndone\n```\n:::\n:::\n\n\nAdvanced:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# load the modules needed for samtools\nmodule load bioinfo-tools samtools/1.3\n\ncd $1\n\n# use ls to get the list to iterate over.\n# $1 contains the first argument given to the program\nfor file in *.sam;\ndo\n\n    # basename will remove the path information to the file, and will also remove the .sam ending\n    filename_bam=$(basename $file .sam)\n\n    # add the .bam file ending to the filename\n    filename_bam=$filename_bam.bam\n\n    # check if the intended output file does not already exists.\n    if [ ! -f $filename_bam ];\n    then\n\n        # print a message to the screen so that the user knows what is happening.\n        echo \"Converting $file to $filename_bam\"\n\n        # do the actual converting\n        samtools view -bS $file > $filename_bam\n\n    else\n        # inform the user that the conversion is skipped\n        echo \"Skipping conversion of $file as $filename_bam already exist\"\n    fi\ndone\n```\n:::\n:::\n\n\n### Bonus exercise 1  \n\nMaths and programming are usually a very good combination, so many of the examples of programming you'll see involve some kind of maths. Now we will write a loop that will calculate the factorial of a number. As [wikipedia will tell you](https://en.wikipedia.org/wiki/Factorial), \"the factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n\", i.e. multiply all the integers, starting from 1, leading up to and including a number with each other.\n\nThe factorial of 5, written 5!, would be `1*2*3*4*5=120`. Doing this by hand would start taking its time even after a couple of steps, but since we know how to loop that should not be a problem anymore.\n\n{{< fa clipboard-list >}} Write a loop that will calculate the factorial of a given number stored in the variable `$n`.\n\n::: {.callout-tip}\nA problem that you will encounter is that the sequence expression, `{1..10}`, from the previous exercise doesn't handle variables. This is because of the way bash is built. The sequence expressions are handled before handling the variables so when bash tries to generate the sequence, the variable names have not yet been replaced with the values they contain. This leads to bash trying to create a sequence from 1 to `$n`, which of course doesn't mean anything.\n\nTo get around this we can use a different way of generating sequences (there are **always** alternatives). There is a program called `seq` that does pretty much the same thing as the sequence expression, and since it is a program it will be executed **after** the variables have been handled. It's as easy to use as the sequence expressions; instead of writing `{1..10}` just write `$( seq 1 10 )`.\n\nThe `$()` tells bash to run something in a subshell, which pretty much means it will run the command within the paratheses and then take whatever that command printed to the screen and replace the parantheses e\nxpression:\n\n```bash\necho $(seq 1 5)\n```\n\nbecomes\n\n```\necho 1 2 3 4 5\n```\n\n:::\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# set the number you want to calculate the factorial of\nn=10\n\n# you have to initialize a variable before you can start using it.\n# Leaving this empty would lead to the first iteration of the loop trying\n# to use a variable that has no value, which would cause it to crash\nfactorial=1\n\n# declare the values the loop will loop over (1 to whatever $n is)\nfor i in $( seq 1 $n );\ndo\n\n    # set factorial to whatever factorial is at the moment, multiplied with the variable $i\n    factorial=$(( $factorial * $i ))\n\n    # an alternative solution which gives exactly the same result, but makes it a bit more readable maybe\n    # temporary_sum=$(( $factorial * $i ))\n    # factorial=$temporary_sum\n\ndone\n\n# print the result\necho The factorial of $n is $factorial\n```\n:::\n:::\n\n\n### Bonus exercise 2\n\nNow, let's combine everything you've learned so far in this course.\n\n{{< fa clipboard-list >}} Write a script that runs the pipeline from the Bioinformatics filetypes lab for each fastq file in a specified directory, using the same reference genome as in the file type exercise. Navigate to the **Linux 2: File types in Bioinformatics** lab on the **Contents** page.\n\nIf that sounds too easy, make the script submit a slurm job for each sample that will run the pipeline for that sample on a calculation node (1 core, 5 minutes each). And if that is too easy, add that the pipeline will use the local hard drive on the calculation node for all files used in the analysis.\n\nWhen the analysis is done, only fastq files and sorted and indexed BAM files should be in your folder.\n\n{{< fa lightbulb >}} Read more about the `$SNIC_TMP` variable in the [disk storage guide](http://www.uppmax.uu.se/support/user-guides/disk-storage-guide/) on the UPPMAX homepage.\n\nThere is a bunch of fastq files in the directory `/proj/snic2023-xx-xxxx/nobackup/username/linux_advanced/fastq/` that is to be used for this exercise.\n\nBasic solution:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# make the dummy pipeline available\nexport PATH=$PATH:/sw/courses/ngsintro/linux/uppmax_pipeline_exercise/dummy_scripts\n\n# index the reference genome\nreference_indexer -r /proj/snic2023-xx-xxxx/nobackup/username/filetypes/0_ref/ad2.fa\n\n# go to the input files\ncd $1\n\n# loop over all the fastq files\nfor file in *.fastq;\ndo\n\n    # align the reads\n    align_reads -r /proj/snic2023-xx-xxxx/nobackup/username/filetypes/0_ref/ad2.fa -i $file -o $file.sam\n\n    # convert the sam file to a bam file\n    sambam_tool -f bam -i $file.sam -o $file.bam\n\n    # sort the bam file\n    sambam_tool -f sort -i $file.bam -o $file.sorted.bam\n\n    # index the bam file\n    sambam_tool -f index -i $file.sorted.bam\n\ndone\n```\n:::\n:::\n\n\nAdvanced solution:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```{.bash}\n# make the dummy pipeline available in this script\nexport PATH=$PATH:/sw/courses/ngsintro/linux/uppmax_pipeline_exercise/dummy_scripts\n\n# index the reference genome once, only if needed\nif [ ! -f /proj/snic2023-xx-xxxx/nobackup/username/filetypes/0_ref/ad2.fa.idx ];\nthen\n    reference_indexer -r /proj/snic2023-xx-xxxx/nobackup/username/filetypes/0_ref/ad2.fa\nfi\n\n\n# find out the absolute path to the input files\ncd $1\ninput_absolute_path=$(pwd)\n\n# go back to the previous directory now that the absolute path has been saved\ncd -\n\n\n\n# loop over all the fastq files\nfor file in $input_absolute_path/*.fastq;\ndo\n\n    # print status report\n    echo Processing $file\n\n    # save the file name without the path information for convenience\n    file_basename=$(basename $file)\n\n    # save the file name without the file ending for convenience\n    file_prefix=$(basename $file .fastq)\n\n    # print a temporary script file that will be submitted to slurm\n    echo \"#!/bin/bash -l\n\n    #SBATCH -A snic2023-xx-xxxx\n    #SBATCH -p core\n    #SBATCH -n 1\n    #SBATCH -t 00:05:00\n    #SBATCH -J $file_basename\n\n    # make the dummy pipeline available on the calculation node\n    echo \"Loading modules\"\n    export PATH=$PATH:/sw/courses/ngsintro/linux/uppmax_pipeline_exercise/dummy_scripts\n\n    # copy the reference genome, index and sample file to the nodes local hard drive.\n    # You have to escape the dollar sign in SNIC_TMP to keep bash from resolving\n    # it to its value in the submitter script already.\n    echo \"Copying data to node local hard drive\"\n    cp /proj/snic2023-xx-xxxx/nobackup/username/filetypes/0_ref/ad2.fa* $file $SNIC_TMP/\n\n    # go the the nodes local hard drive\n    echo \"Changing directory to node local hard drive\"\n    cd $SNIC_TMP\n\n    # align the reads\n    echo \"Aligning the reads\"\n    align_reads -r ad2.fa -i $file_basename -o $file_prefix.sam\n\n    # convert the SAM file to a BAM file\n    echo \"Converting sam to bam\"\n    sambam_tool -f bam -i $file_prefix.sam -o $file_prefix.bam\n\n    # sort the BAM file\n    echo \"Sorting the bam file\"\n    sambam_tool -f sort -i $file_prefix.bam -o $file_prefix.sorted.bam\n\n    # index the BAM file\n    echo \"Indexing the sorted bam file\"\n    sambam_tool -f index -i $file_prefix.sorted.bam\n\n    # copy back the files you want to keep\n    echo \"Copying results back to network storage\"\n    cp $file_prefix.sorted.bam $input_absolute_path/\n    cp $file_prefix.sorted.bam.bai $input_absolute_path/$file_prefix.sorted.bai\n\n    echo \"Finished\"\n    \" > tmp.sbatch\n\n    # submit the temporary script file\n    sbatch tmp.sbatch\n\ndone\n\n# remove the temporary file now that everything has been submitted\nrm tmp.sbatch\n```\n:::\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}